import requests

def save_results_to_file(results, commands, filename="vulnerabilities_report.txt"):
    """Guarda los resultados del escaneo en un archivo."""
    with open(filename, "w") as f:
        f.write("Resultados de la Herramienta de Vulnerabilidades\n")
        f.write("=" * 50 + "\n")
        f.write(f"{'Vulnerabilidad':<25} {'Detalles':<25}\n")
        f.write("-" * 50 + "\n")
        for result in results:
            f.write(f"{result['name']:<25} {result['details']:<25}\n")
        f.write("\nComandos Utilizados:\n")
        f.write("=" * 50 + "\n")
        for command in commands:
            f.write(f"{command}\n")
    print(f"[INFO] Resultados guardados en {filename}")

def check_security_headers(target):
    """Verifica la presencia de encabezados de seguridad en el objetivo."""
    print(f"\n[INFO] Verificando encabezados de seguridad en: {target}")
    headers_to_check = [
        "Content-Security-Policy",
        "X-Frame-Options",
        "X-Content-Type-Options",
        "Strict-Transport-Security",
        "X-XSS-Protection",
        "Referrer-Policy"
    ]
    vulnerabilities = []

    try:
        response = requests.get(f"http://{target}", timeout=5)
        headers = response.headers
        for header in headers_to_check:
            if header not in headers:
                vulnerabilities.append({"name": "Falta encabezado", "details": header})
    except Exception as e:
        print(f"[ERROR] Error al verificar encabezados: {e}")
    return vulnerabilities

def generic_vulnerability_scan(target):
    """
    Realiza un escaneo genérico de vulnerabilidades en el objetivo.
    Verifica la presencia de encabezados de seguridad y realiza otras comprobaciones básicas.
    """
    print(f"[INFO] Iniciando escaneo de vulnerabilidades en {target}...")

    vulnerabilities = []
    
    # Verificación de encabezados de seguridad
    header_vulns = check_security_headers(target)
    vulnerabilities.extend(header_vulns)
    
    # Comprobación de HSTS
    try:
        response = requests.get(f"http://{target}", timeout=5)
        if "Strict-Transport-Security" not in response.headers:
            vulnerabilities.append({"name": "Falta encabezado HSTS", "details": "Strict-Transport-Security"})
    except Exception as e:
        print(f"[ERROR] Error al verificar HSTS: {e}")

    # Comprobación si el sitio utiliza HTTPS
    if not target.startswith("https"):
        vulnerabilities.append({"name": "Posible falta de HTTPS", "details": "El sitio no usa HTTPS"})

    # Comprobación básica para detectar XSS
    xss_check_url = f"http://{target}/<script>alert('XSS')</script>"
    try:
        xss_response = requests.get(xss_check_url, timeout=5)
        if "<script>alert('XSS')</script>" in xss_response.text:
            vulnerabilities.append({"name": "Posible Vulnerabilidad XSS", "details": "El sitio refleja scripts no sanitizados."})
    except Exception as e:
        print(f"[ERROR] Error al verificar XSS: {e}")

    # Comprobación adicional para SQL Injection
    sql_injection_test_url = f"http://{target}/?id=1' OR '1'='1"
    
    try:
        response = requests.get(sql_injection_test_url, timeout=5)
        if 'error' in response.text.lower():  # Simplista; se puede mejorar según el contexto
            vulnerabilities.append({"name": "Posible Vulnerabilidad SQL Injection", "details": "Respuesta indica posible SQL Injection."})
        
    except Exception as e:
        print(f"[ERROR] Error al verificar SQL Injection: {e}")

    return vulnerabilities

def check_for_ssl(target):
    """Verifica si el objetivo tiene un certificado SSL válido."""
    try:
        response = requests.get(f"https://{target}", timeout=5)
        if response.status_code == 200:
            return [{"name": "SSL Válido", "details": f"El sitio usa HTTPS."}]
        else:
            return [{"name": "Problema con SSL", "details": f"El sitio no responde correctamente a HTTPS."}]
    except requests.exceptions.SSLError:
        return [{"name": "Error SSL", "details": "El certificado SSL es inválido."}]
    except Exception as e:
        print(f"[ERROR] Error al verificar SSL: {e}")
        return []

def scan_for_common_vulnerabilities(target):
    """Realiza un escaneo para vulnerabilidades comunes adicionales."""
    common_vulns = []
    
    # Ejemplo: Comprobación para Open Redirect
    open_redirect_test_url = f"http://{target}/redirect?url=http://malicious.com"
    
    try:
        response = requests.get(open_redirect_test_url, timeout=5)
        if response.url != open_redirect_test_url:  # Si redirige a otra URL
            common_vulns.append({"name": "Posible Vulnerabilidad Open Redirect", "details": "El sitio redirige a URLs externas."})
        
    except Exception as e:
        print(f"[ERROR] Error al verificar Open Redirect: {e}")

    return common_vulns
