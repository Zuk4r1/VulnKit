import argparse
import importlib
import os
from datetime import datetime
from concurrent.futures import ThreadPoolExecutor
import dns.query
import dns.zone
import requests
from bs4 import BeautifulSoup  # Para la función spider
from utils import save_results_to_file, check_security_headers, generic_vulnerability_scan

BANNER = r"""
Herramienta desarrollada por @Zuk4r1
██╗   ██╗██╗   ██╗██╗     ███╗   ██╗██╗  ██╗██╗████████╗
██║   ██║██║   ██║██║     ████╗  ██║██║ ██╔╝██║╚══██╔══╝
██║   ██║██║   ██║██║     ██╔██╗ ██║█████╔╝ ██║   ██║
╚██╗ ██╔╝██║   ██║██║     ██║╚██╗██║██╔═██╗ ██║   ██║
 ╚████╔╝ ╚██████╔╝███████╗██║ ╚████║██║  ██╗██║   ██║
  ╚═══╝   ╚═════╝ ╚══════╝╚═╝  ╚═══╝╚═╝  ╚═╝╚═╝   ╚═╝
Escáneo avanzado de vulnerabilidades y exploits.
	versión 1.1.1.0
"""
"""

def list_exploits():
    return [
        "dt", "sqli", "rce", "ssrf", "xss", "deserialization",
        "ldap_injection", "csrf", "x_frame", "https", "file_upload", 
        "graphql_injection", "xml_external_entity_injection", 
        "command_injection", "open_redirect", "xxe"
    ]

def scan_file_uploads(target):
    print(f"[INFO] Escaneando cargas de archivos en {target}...")
    vulnerabilities = []
    
    response = requests.get(f"http://{target}/upload")
    
    if 'upload' in response.text:
        # Intentar cargar un archivo malicioso con una lista de archivos existentes en el sistema local.
        malicious_files = [
            'malicious.jpg.php', 'malicious.php', 'malicious.exe',
            'malicious.pdf', 'malicious.zip', 'malicious.gif',
            'malicious.jsp', 'malicious.svg', 'malicious.txt',
            'malicious.php3', 'malicious.phtml', 'malicious.py'
        ]
        
        for file in malicious_files:
            if os.path.exists(file):  # Verificar si el archivo existe antes de intentar cargarlo.
                print(f"[INFO] Intentando cargar archivo: {file}")
                files = {'file': open(file, 'rb')}
                upload_response = requests.post(f"http://{target}/upload", files=files)
                
                if upload_response.status_code == 200 and 'success' in upload_response.text.lower():
                    vulnerabilities.append({"name": "File Upload Vulnerability", 
                                            "details": f"Posible carga insegura detectada con {file}"})
            else:
                print(f"[WARNING] Archivo no encontrado: {file}")
    
    return vulnerabilities

def scan_graphql_injection(target):
    print(f"[INFO] Escaneando inyecciones en GraphQL en {target}...")
    vulnerabilities = []
    
    # Exploración exhaustiva con consultas maliciosas
    malicious_queries = [
        "{ __schema { types { name } } }",
        "mutation { deleteUser(id: 1) }",
        "{ users { id name email password sensitiveData } }",
        "{ posts { title content author { id name } } }",
        "{ __type(name: \"User\") { fields { name type { name } } } }",
        "{ login(username: \"admin\", password: \"password\") { token } }",
        "{ user(id: \"1\") { password roles permissions lastLogin } }",
        "{ allUsers { id name email role password lastLogin createdAt updatedAt } }"
    ]
    
    for query in malicious_queries:
        response = requests.post(f"http://{target}/graphql", json={"query": query})
        
        if response.status_code == 200 and 'errors' not in response.json():
            vulnerabilities.append({"name": "GraphQL Injection Vulnerability", 
                                    "details": f"Consulta maliciosa permitida: {query}"})
    
    return vulnerabilities

def run_exploit(exploit_name, target):
    try:
        print(f"[INFO] Cargando exploit: {exploit_name}")
        module = importlib.import_module(f"exploits.exploit_{exploit_name}")
        return module.execute(target)
    except ModuleNotFoundError:
        return {"name": f"[ERROR] Exploit '{exploit_name}' no encontrado.", "details": ""}
    except Exception as e:
        return {"name": "[ERROR]", "details": f"Error al ejecutar el exploit: {e}"}

def scan_target(target, args):
    results = []
    
    with ThreadPoolExecutor() as executor:
        futures = []
        
        if args.scan_generic:
            print("[INFO] Realizando escaneo genérico de vulnerabilidades...")
            futures.append(executor.submit(generic_vulnerability_scan, target))
        
        if args.scan_headers:
            print("[INFO] Escaneando encabezados de seguridad...")
            futures.append(executor.submit(check_security_headers, target))
        
        if args.scan_file_upload:
            futures.append(executor.submit(scan_file_uploads, target))
        
        if args.scan_graphql_injection:
            futures.append(executor.submit(scan_graphql_injection, target))
        
        if args.scan_all or args.exploit:
            exploits_to_run = [args.exploit] if args.exploit else list_exploits()
            
            for exploit in exploits_to_run:
                futures.append(executor.submit(run_exploit, exploit, target))
        
        for future in futures:
            results.extend(future.result())
    
    return results

def check_security_headers(target):
    """ Escanea encabezados de seguridad y proporciona recomendaciones. """
    print(f"[INFO] Verificando encabezados de seguridad en {target}...")
    
    headers_to_check = [
        'Content-Security-Policy', 'Permissions-Policy', 'Referrer-Policy',
        'X-Content-Type-Options', 'X-Frame-Options', 'Strict-Transport-Security',
        'X-XSS-Protection', 'Feature-Policy', 'Access-Control-Allow-Origin',
        'Public-Key-Pins', 'Content-Type', 
        'Expect-CT', 'Cross-Origin-Embedder-Policy', 
        'Cross-Origin-Opener-Policy', 'Access-Control-Allow-Credentials',
        'Access-Control-Allow-Headers'
    ]
    
    recommendations = []
    
    for header in headers_to_check:
        response = requests.get(f"http://{target}")
        
        if header not in response.headers:
            recommendations.append({
                "name": f"[WARNING] Encabezado ausente: {header}",
                "details": f"El encabezado {header} debería estar presente para mejorar la seguridad."
            })
    
    return recommendations

def check_insecure_deserialization(target):
    """ Verifica la posibilidad de deserialización insegura en el objetivo. """
    print(f"[INFO] Verificando deserialización insegura en {target}...")
    
    test_payloads = [
        {"lang": "PHP", "payload": b"serialized_object"},
        {"lang": "Java", "payload": b"java:some_serialized_object"},
        {"lang": ".NET", "payload": b"binary_formatter_object"},
        {"lang": "Python", "payload": b"__import__('os').system('ls')"},
        {"lang": "Ruby", "payload": b"Marshal.load('...')"},
        {"lang": "NodeJS", "payload": b"require('child_process').exec('ls')"},
        {"lang": "Go", "payload": b"encoding/gob"},
        {"lang": "C#", "payload": b"System.Runtime.Serialization.Formatters.Binary.BinaryFormatter"},
        {"lang": "Swift", "payload": b"NSKeyedUnarchiver.unarchiveObject(with:)"},
    ]
    
    vulnerabilities = []
    
    for test in test_payloads:
        response = send_payload(target, test["payload"])
        
        if response and is_vulnerable(response):
            vulnerabilities.append({"name": f"Deserialización insegura ({test['lang']})", 
                                    "details": f"Vulnerabilidad detectada con payload: {test['payload']}"})
    
    return vulnerabilities

def send_payload(target, payload):
    """ Envía un payload al servidor objetivo y devuelve la respuesta. """
    try:
        response = requests.post(f"http://{target}/api/test", data=payload)
        return response.text
    except Exception as e:
        print(f"[ERROR] Error al enviar el payload: {e}")
        return None

def is_vulnerable(response):
    """ Analiza la respuesta del servidor para determinar si es vulnerable. """
    return 'error' in response.lower()

def check_dns_zone_transfer(target):
    """ Verifica si es posible realizar una transferencia de zona DNS en el objetivo. """
    print(f"[INFO] Verificando transferencia de zona DNS en {target}...")
    
    results = []
    
    try:
        ns_query = dns.resolver.resolve(target, 'NS')
        
        for ns in ns_query:
            try:
                zone = dns.zone.from_xfr(dns.query.xfr(str(ns), target))
                records = zone.nodes.keys()
                dns_records = [str(record) for record in records]
                results.append({"name": "Transferencia de zona DNS exitosa", 
                                "details": f"Registros obtenidos: {dns_records}"})
            except Exception as e:
                print(f"[ERROR] No se pudo realizar la transferencia de zona en {ns}: {e}")
                results.append({"name": "[ERROR]", 
                                "details": f"No se pudo realizar la transferencia de zona en {ns}."})
                
    except Exception as e:
        print(f"[ERROR] Error al resolver NS: {e}")
        results.append({"name": "[ERROR]", 
                        "details": "No se pudo realizar la transferencia de zona DNS."})
    
    return results

def spider(target):
    """ Función avanzada para explorar el sitio web y encontrar enlaces y formularios. """
    print(f"[INFO] Explorando enlaces en {target}...")
    
    try:
        response = requests.get(f"http://{target}")
        
        if response.status_code == 200:
            soup = BeautifulSoup(response.text, 'html.parser')
            
            # Encuentra todos los enlaces en la página
            links = set()
            for link in soup.find_all('a', href=True):
                links.add(link['href'])
            
            # Encuentra formularios y sus métodos
            forms = soup.find_all('form')
            form_details = []
            
            for form in forms:
                action = form.get('action')
                method = form.get('method', 'GET').upper()
                inputs = form.find_all('input')
                input_details = [{'type': input.get('type'), 'name': input.get('name')} for input in inputs]
                
                form_details.append({
                    'action': action,
                    'method': method,
                    'inputs': input_details
                })
            
            # Guardar resultados encontrados durante el escaneo del spider
            results = {
                'links': list(links),
                'forms': form_details,
                'title': soup.title.string if soup.title else ''
            }
            
            print("[INFO] Enlaces encontrados:")
            for link in results['links']:
                print(f" - {link}")
                
            print("[INFO] Formularios encontrados:")
            for form in results['forms']:
                print(f" - Acción: {form['action']}, Método: {form['method']}, Inputs: {[input['name'] for input in form['inputs']]}")
                
            return results
        
    except Exception as e:
        print(f"[ERROR] Error al explorar el sitio web: {e}")

def main():
    print(BANNER)
    
    parser = argparse.ArgumentParser(description="Herramienta de auditoría de vulnerabilidades y explotación.")
    
    parser.add_argument("target", help="Dominio o IP del objetivo a analizar")
    
    parser.add_argument("--exploit", help="Nombre del exploit a ejecutar", choices=list_exploits())
    
    parser.add_argument("--scan-headers", action="store_true", help="Escanea encabezados de seguridad")
    
    parser.add_argument("--scan-all", action="store_true", help="Ejecuta todos los exploits disponibles")
    
    parser.add_argument("--scan-generic", action="store_true", help="Escanea vulnerabilidades genéricas no cubiertas por exploits")
    
    parser.add_argument("--scan-file-upload", action="store_true", help="Escanea vulnerabilidades de carga de archivos")
    
    parser.add_argument("--scan-graphql-injection", action="store_true", help="Escanea inyecciones en GraphQL")
    
    parser.add_argument("--check-deserialization", action="store_true", help="Verifica deserialización insegura")
    
    parser.add_argument("--check-dns-transfer", action="store_true", help="Verifica transferencia de zona DNS")
    
    parser.add_argument("--spider", action="store_true", help="Explora enlaces del sitio web")
    
    args = parser.parse_args()
    
    results = scan_target(args.target, args)
    
    if args.check_deserialization:
        results.extend(check_insecure_deserialization(args.target))
        
    if args.check_dns_transfer:
        results.extend(check_dns_zone_transfer(args.target))
        
    if args.spider:
        spider(args.target)
        
    timestamp = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
    
    output_file = f"Report_{timestamp}.txt"
    
    if results:
        print("\n[INFO] Resultados encontrados:")
        
        for result in results:
            if isinstance(result, dict):  # Asegúrate de que sea un dict
                print(f" - {result['name']}: {result['details']}")
            else:
                print(f"[ERROR] Resultado inesperado: {result}")
                
        save_results_to_file(results, [], output_file)
        
        print(f"[INFO] Resultados guardados en {output_file}")
        
    else:
        print("\n[INFO] No se detectaron vulnerabilidades.")

if __name__ == "__main__":
    main()
